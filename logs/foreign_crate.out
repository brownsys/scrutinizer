[src/fn_visitor.rs:116] fn_call = FnCallInfo {
    def_id: DefId(2:1824 ~ core[f767]::ptr::non_null::{impl#3}::as_ref),
    arg_tys: [
        &std::ptr::NonNull<std::rc::RcBox<T>>,
    ],
    call_span: /Users/artemagvanian/.rustup/toolchains/nightly-2023-04-12-aarch64-apple-darwin/lib/rustlib/src/rust/library/alloc/src/rc.rs:350:27: 350:35 (#0),
    body_span: Some(
        /Users/artemagvanian/.rustup/toolchains/nightly-2023-04-12-aarch64-apple-darwin/lib/rustlib/src/rust/library/core/src/ptr/non_null.rs:373:5: 377:6 (#0),
    ),
    body_checked: true,
    raw_ptr_deref: true,
}
[src/fn_visitor.rs:124] body_snippet = "pub const unsafe fn as_ref<'a>(&self) -> &'a T {\n        // SAFETY: the caller must guarantee that `self` meets all the\n        // requirements for a reference.\n        unsafe { &*self.as_ptr() }\n    }"
[src/fn_visitor.rs:116] fn_call = FnCallInfo {
    def_id: DefId(2:4204 ~ core[f767]::cell::{impl#10}::get),
    arg_tys: [
        &std::cell::Cell<usize>,
    ],
    call_span: /Users/artemagvanian/.rustup/toolchains/nightly-2023-04-12-aarch64-apple-darwin/lib/rustlib/src/rust/library/alloc/src/rc.rs:2624:27: 2624:32 (#0),
    body_span: Some(
        /Users/artemagvanian/.rustup/toolchains/nightly-2023-04-12-aarch64-apple-darwin/lib/rustlib/src/rust/library/core/src/cell.rs:498:5: 502:6 (#0),
    ),
    body_checked: true,
    raw_ptr_deref: true,
}
[src/fn_visitor.rs:124] body_snippet = "pub fn get(&self) -> T {\n        // SAFETY: This can cause data races if called from a separate thread,\n        // but `Cell` is `!Sync` so this won't happen.\n        unsafe { *self.value.get() }\n    }"
[src/fn_visitor.rs:116] fn_call = FnCallInfo {
    def_id: DefId(2:4200 ~ core[f767]::cell::{impl#9}::replace),
    arg_tys: [
        &std::cell::Cell<T>,
        T,
    ],
    call_span: /Users/artemagvanian/.rustup/toolchains/nightly-2023-04-12-aarch64-apple-darwin/lib/rustlib/src/rust/library/core/src/cell.rs:412:24: 412:36 (#0),
    body_span: Some(
        /Users/artemagvanian/.rustup/toolchains/nightly-2023-04-12-aarch64-apple-darwin/lib/rustlib/src/rust/library/core/src/cell.rs:459:5: 463:6 (#0),
    ),
    body_checked: true,
    raw_ptr_deref: true,
}
[src/fn_visitor.rs:124] body_snippet = "pub fn replace(&self, val: T) -> T {\n        // SAFETY: This can cause data races if called from a separate thread,\n        // but `Cell` is `!Sync` so this won't happen.\n        mem::replace(unsafe { &mut *self.value.get() }, val)\n    }"
[src/fn_visitor.rs:116] fn_call = FnCallInfo {
    def_id: DefId(2:2160 ~ core[f767]::ptr::read),
    arg_tys: [
        *const T,
    ],
    call_span: /Users/artemagvanian/.rustup/toolchains/nightly-2023-04-12-aarch64-apple-darwin/lib/rustlib/src/rust/library/core/src/mem/mod.rs:909:22: 909:37 (#0),
    body_span: Some(
        /Users/artemagvanian/.rustup/toolchains/nightly-2023-04-12-aarch64-apple-darwin/lib/rustlib/src/rust/library/core/src/ptr/mod.rs:1137:1: 1191:2 (#0),
    ),
    body_checked: true,
    raw_ptr_deref: true,
}
[src/fn_visitor.rs:124] body_snippet = "pub const unsafe fn read<T>(src: *const T) -> T {\n    // It would be semantically correct to implement this via `copy_nonoverlapping`\n    // and `MaybeUninit`, as was done before PR #109035. Calling `assume_init`\n    // provides enough information to know that this is a typed operation.\n\n    // However, as of March 2023 the compiler was not capable of taking advantage\n    // of that information.  Thus the implementation here switched to an intrinsic,\n    // which lowers to `_0 = *src` in MIR, to address a few issues:\n    //\n    // - Using `MaybeUninit::assume_init` after a `copy_nonoverlapping` was not\n    //   turning the untyped copy into a typed load. As such, the generated\n    //   `load` in LLVM didn't get various metadata, such as `!range` (#73258),\n    //   `!nonnull`, and `!noundef`, resulting in poorer optimization.\n    // - Going through the extra local resulted in multiple extra copies, even\n    //   in optimized MIR.  (Ignoring StorageLive/Dead, the intrinsic is one\n    //   MIR statement, while the previous implementation was eight.)  LLVM\n    //   could sometimes optimize them away, but because `read` is at the core\n    //   of so many things, not having them in the first place improves what we\n    //   hand off to the backend.  For example, `mem::replace::<Big>` previously\n    //   emitted 4 `alloca` and 6 `memcpy`s, but is now 1 `alloc` and 3 `memcpy`s.\n    // - In general, this approach keeps us from getting any more bugs (like\n    //   #106369) that boil down to \"`read(p)` is worse than `*p`\", as this\n    //   makes them look identical to the backend (or other MIR consumers).\n    //\n    // Future enhancements to MIR optimizations might well allow this to return\n    // to the previous implementation, rather than using an intrinsic.\n\n    // SAFETY: the caller must guarantee that `src` is valid for reads.\n    unsafe {\n        assert_unsafe_precondition!(\n            \"ptr::read requires that the pointer argument is aligned and non-null\",\n            [T](src: *const T) => is_aligned_and_not_null(src)\n        );\n\n        #[cfg(bootstrap)]\n        {\n            // We are calling the intrinsics directly to avoid function calls in the\n            // generated code as `intrinsics::copy_nonoverlapping` is a wrapper function.\n            extern \"rust-intrinsic\" {\n                #[rustc_const_stable(feature = \"const_intrinsic_copy\", since = \"1.63.0\")]\n                fn copy_nonoverlapping<T>(src: *const T, dst: *mut T, count: usize);\n            }\n\n            // `src` cannot overlap `tmp` because `tmp` was just allocated on\n            // the stack as a separate allocated object.\n            let mut tmp = MaybeUninit::<T>::uninit();\n            copy_nonoverlapping(src, tmp.as_mut_ptr(), 1);\n            tmp.assume_init()\n        }\n        #[cfg(not(bootstrap))]\n        {\n            crate::intrinsics::read_via_copy(src)\n        }\n    }\n}"
[src/fn_visitor.rs:116] fn_call = FnCallInfo {
    def_id: DefId(2:1345 ~ core[f767]::intrinsics::{extern#0}::ctpop),
    arg_tys: [
        u64,
    ],
    call_span: /Users/artemagvanian/.rustup/toolchains/nightly-2023-04-12-aarch64-apple-darwin/lib/rustlib/src/rust/library/core/src/num/uint_macros.rs:107:13: 107:48 (#23),
    body_span: None,
    body_checked: false,
    raw_ptr_deref: false,
}
[src/fn_visitor.rs:116] fn_call = FnCallInfo {
    def_id: DefId(2:1260 ~ core[f767]::intrinsics::{extern#0}::caller_location),
    arg_tys: [],
    call_span: /Users/artemagvanian/.rustup/toolchains/nightly-2023-04-12-aarch64-apple-darwin/lib/rustlib/src/rust/library/core/src/panic/location.rs:88:9: 88:45 (#0),
    body_span: None,
    body_checked: false,
    raw_ptr_deref: false,
}
[src/fn_visitor.rs:116] fn_call = FnCallInfo {
    def_id: DefId(2:8282 ~ core[f767]::panicking::panic_fmt::{extern#0}::panic_impl),
    arg_tys: [
        &std::panic::PanicInfo<'_>,
    ],
    call_span: /Users/artemagvanian/.rustup/toolchains/nightly-2023-04-12-aarch64-apple-darwin/lib/rustlib/src/rust/library/core/src/panicking.rs:67:14: 67:29 (#0),
    body_span: None,
    body_checked: false,
    raw_ptr_deref: false,
}
[src/fn_visitor.rs:116] fn_call = FnCallInfo {
    def_id: DefId(2:8285 ~ core[f767]::panicking::panic_nounwind_fmt::{extern#0}::panic_impl),
    arg_tys: [
        &std::panic::PanicInfo<'_>,
    ],
    call_span: /Users/artemagvanian/.rustup/toolchains/nightly-2023-04-12-aarch64-apple-darwin/lib/rustlib/src/rust/library/core/src/panicking.rs:96:14: 96:29 (#0),
    body_span: None,
    body_checked: false,
    raw_ptr_deref: false,
}
[src/fn_visitor.rs:116] fn_call = FnCallInfo {
    def_id: DefId(2:1238 ~ core[f767]::intrinsics::{extern#0}::unlikely),
    arg_tys: [
        bool,
    ],
    call_span: /Users/artemagvanian/.rustup/toolchains/nightly-2023-04-12-aarch64-apple-darwin/lib/rustlib/src/rust/library/alloc/src/rc.rs:2645:12: 2645:51 (#0),
    body_span: None,
    body_checked: false,
    raw_ptr_deref: false,
}
[src/fn_visitor.rs:116] fn_call = FnCallInfo {
    def_id: DefId(2:1234 ~ core[f767]::intrinsics::{extern#0}::abort),
    arg_tys: [],
    call_span: /Users/artemagvanian/.rustup/toolchains/nightly-2023-04-12-aarch64-apple-darwin/lib/rustlib/src/rust/library/alloc/src/rc.rs:2646:13: 2646:20 (#0),
    body_span: None,
    body_checked: false,
    raw_ptr_deref: false,
}
Body purity check result for function foreign_crate: false