[src/fn_visitor.rs:116] fn_call = FnCallInfo {
    def_id: DefId(2:1260 ~ core[f767]::intrinsics::{extern#0}::caller_location),
    arg_tys: [],
    call_span: /Users/artemagvanian/.rustup/toolchains/nightly-2023-04-12-aarch64-apple-darwin/lib/rustlib/src/rust/library/core/src/panic/location.rs:88:9: 88:45 (#0),
    body_span: None,
    body_checked: false,
    raw_ptr_deref: false,
}
[src/fn_visitor.rs:116] fn_call = FnCallInfo {
    def_id: DefId(2:8282 ~ core[f767]::panicking::panic_fmt::{extern#0}::panic_impl),
    arg_tys: [
        &std::panic::PanicInfo<'_>,
    ],
    call_span: /Users/artemagvanian/.rustup/toolchains/nightly-2023-04-12-aarch64-apple-darwin/lib/rustlib/src/rust/library/core/src/panicking.rs:67:14: 67:29 (#0),
    body_span: None,
    body_checked: false,
    raw_ptr_deref: false,
}
[src/fn_visitor.rs:116] fn_call = FnCallInfo {
    def_id: DefId(2:1094 ~ core[f767]::intrinsics::{extern#0}::atomic_load_relaxed),
    arg_tys: [
        *const T,
    ],
    call_span: /Users/artemagvanian/.rustup/toolchains/nightly-2023-04-12-aarch64-apple-darwin/lib/rustlib/src/rust/library/core/src/sync/atomic.rs:3159:24: 3159:60 (#0),
    body_span: None,
    body_checked: false,
    raw_ptr_deref: false,
}
[src/fn_visitor.rs:116] fn_call = FnCallInfo {
    def_id: DefId(2:1092 ~ core[f767]::intrinsics::{extern#0}::atomic_load_acquire),
    arg_tys: [
        *const T,
    ],
    call_span: /Users/artemagvanian/.rustup/toolchains/nightly-2023-04-12-aarch64-apple-darwin/lib/rustlib/src/rust/library/core/src/sync/atomic.rs:3160:24: 3160:60 (#0),
    body_span: None,
    body_checked: false,
    raw_ptr_deref: false,
}
[src/fn_visitor.rs:116] fn_call = FnCallInfo {
    def_id: DefId(2:1090 ~ core[f767]::intrinsics::{extern#0}::atomic_load_seqcst),
    arg_tys: [
        *const T,
    ],
    call_span: /Users/artemagvanian/.rustup/toolchains/nightly-2023-04-12-aarch64-apple-darwin/lib/rustlib/src/rust/library/core/src/sync/atomic.rs:3161:23: 3161:58 (#0),
    body_span: None,
    body_checked: false,
    raw_ptr_deref: false,
}
[src/fn_visitor.rs:116] fn_call = FnCallInfo {
    def_id: DefId(2:4200 ~ core[f767]::cell::{impl#9}::replace),
    arg_tys: [
        &std::cell::Cell<T>,
        T,
    ],
    call_span: /Users/artemagvanian/.rustup/toolchains/nightly-2023-04-12-aarch64-apple-darwin/lib/rustlib/src/rust/library/core/src/cell.rs:616:14: 616:41 (#0),
    body_span: Some(
        /Users/artemagvanian/.rustup/toolchains/nightly-2023-04-12-aarch64-apple-darwin/lib/rustlib/src/rust/library/core/src/cell.rs:459:5: 463:6 (#0),
    ),
    body_checked: true,
    raw_ptr_deref: true,
}
[src/fn_visitor.rs:124] body_snippet = "pub fn replace(&self, val: T) -> T {\n        // SAFETY: This can cause data races if called from a separate thread,\n        // but `Cell` is `!Sync` so this won't happen.\n        mem::replace(unsafe { &mut *self.value.get() }, val)\n    }"
[src/fn_visitor.rs:116] fn_call = FnCallInfo {
    def_id: DefId(2:2160 ~ core[f767]::ptr::read),
    arg_tys: [
        *const T,
    ],
    call_span: /Users/artemagvanian/.rustup/toolchains/nightly-2023-04-12-aarch64-apple-darwin/lib/rustlib/src/rust/library/core/src/mem/mod.rs:909:22: 909:37 (#0),
    body_span: Some(
        /Users/artemagvanian/.rustup/toolchains/nightly-2023-04-12-aarch64-apple-darwin/lib/rustlib/src/rust/library/core/src/ptr/mod.rs:1137:1: 1191:2 (#0),
    ),
    body_checked: true,
    raw_ptr_deref: true,
}
[src/fn_visitor.rs:124] body_snippet = "pub const unsafe fn read<T>(src: *const T) -> T {\n    // It would be semantically correct to implement this via `copy_nonoverlapping`\n    // and `MaybeUninit`, as was done before PR #109035. Calling `assume_init`\n    // provides enough information to know that this is a typed operation.\n\n    // However, as of March 2023 the compiler was not capable of taking advantage\n    // of that information.  Thus the implementation here switched to an intrinsic,\n    // which lowers to `_0 = *src` in MIR, to address a few issues:\n    //\n    // - Using `MaybeUninit::assume_init` after a `copy_nonoverlapping` was not\n    //   turning the untyped copy into a typed load. As such, the generated\n    //   `load` in LLVM didn't get various metadata, such as `!range` (#73258),\n    //   `!nonnull`, and `!noundef`, resulting in poorer optimization.\n    // - Going through the extra local resulted in multiple extra copies, even\n    //   in optimized MIR.  (Ignoring StorageLive/Dead, the intrinsic is one\n    //   MIR statement, while the previous implementation was eight.)  LLVM\n    //   could sometimes optimize them away, but because `read` is at the core\n    //   of so many things, not having them in the first place improves what we\n    //   hand off to the backend.  For example, `mem::replace::<Big>` previously\n    //   emitted 4 `alloca` and 6 `memcpy`s, but is now 1 `alloc` and 3 `memcpy`s.\n    // - In general, this approach keeps us from getting any more bugs (like\n    //   #106369) that boil down to \"`read(p)` is worse than `*p`\", as this\n    //   makes them look identical to the backend (or other MIR consumers).\n    //\n    // Future enhancements to MIR optimizations might well allow this to return\n    // to the previous implementation, rather than using an intrinsic.\n\n    // SAFETY: the caller must guarantee that `src` is valid for reads.\n    unsafe {\n        assert_unsafe_precondition!(\n            \"ptr::read requires that the pointer argument is aligned and non-null\",\n            [T](src: *const T) => is_aligned_and_not_null(src)\n        );\n\n        #[cfg(bootstrap)]\n        {\n            // We are calling the intrinsics directly to avoid function calls in the\n            // generated code as `intrinsics::copy_nonoverlapping` is a wrapper function.\n            extern \"rust-intrinsic\" {\n                #[rustc_const_stable(feature = \"const_intrinsic_copy\", since = \"1.63.0\")]\n                fn copy_nonoverlapping<T>(src: *const T, dst: *mut T, count: usize);\n            }\n\n            // `src` cannot overlap `tmp` because `tmp` was just allocated on\n            // the stack as a separate allocated object.\n            let mut tmp = MaybeUninit::<T>::uninit();\n            copy_nonoverlapping(src, tmp.as_mut_ptr(), 1);\n            tmp.assume_init()\n        }\n        #[cfg(not(bootstrap))]\n        {\n            crate::intrinsics::read_via_copy(src)\n        }\n    }\n}"
[src/fn_visitor.rs:116] fn_call = FnCallInfo {
    def_id: DefId(2:1345 ~ core[f767]::intrinsics::{extern#0}::ctpop),
    arg_tys: [
        u64,
    ],
    call_span: /Users/artemagvanian/.rustup/toolchains/nightly-2023-04-12-aarch64-apple-darwin/lib/rustlib/src/rust/library/core/src/num/uint_macros.rs:107:13: 107:48 (#48),
    body_span: None,
    body_checked: false,
    raw_ptr_deref: false,
}
[src/fn_visitor.rs:116] fn_call = FnCallInfo {
    def_id: DefId(2:8285 ~ core[f767]::panicking::panic_nounwind_fmt::{extern#0}::panic_impl),
    arg_tys: [
        &std::panic::PanicInfo<'_>,
    ],
    call_span: /Users/artemagvanian/.rustup/toolchains/nightly-2023-04-12-aarch64-apple-darwin/lib/rustlib/src/rust/library/core/src/panicking.rs:96:14: 96:29 (#0),
    body_span: None,
    body_checked: false,
    raw_ptr_deref: false,
}
[src/fn_visitor.rs:116] fn_call = FnCallInfo {
    def_id: DefId(2:1824 ~ core[f767]::ptr::non_null::{impl#3}::as_ref),
    arg_tys: [
        &std::ptr::NonNull<alloc::sync::ArcInner<T>>,
    ],
    call_span: /Users/artemagvanian/.rustup/toolchains/nightly-2023-04-12-aarch64-apple-darwin/lib/rustlib/src/rust/library/alloc/src/sync.rs:1254:27: 1254:35 (#0),
    body_span: Some(
        /Users/artemagvanian/.rustup/toolchains/nightly-2023-04-12-aarch64-apple-darwin/lib/rustlib/src/rust/library/core/src/ptr/non_null.rs:373:5: 377:6 (#0),
    ),
    body_checked: true,
    raw_ptr_deref: true,
}
[src/fn_visitor.rs:124] body_snippet = "pub const unsafe fn as_ref<'a>(&self) -> &'a T {\n        // SAFETY: the caller must guarantee that `self` meets all the\n        // requirements for a reference.\n        unsafe { &*self.as_ptr() }\n    }"
[src/fn_visitor.rs:116] fn_call = FnCallInfo {
    def_id: DefId(1:6753 ~ std[e490]::sys_common::lazy_box::{impl#1}::deref),
    arg_tys: [
        &std::sys_common::lazy_box::LazyBox<std::sys::unix::locks::pthread_mutex::AllocatedMutex>,
    ],
    call_span: /Users/artemagvanian/.rustup/toolchains/nightly-2023-04-12-aarch64-apple-darwin/lib/rustlib/src/rust/library/std/src/sys/unix/locks/pthread_mutex.rs:14:5: 14:14 (#0),
    body_span: Some(
        /Users/artemagvanian/.rustup/toolchains/nightly-2023-04-12-aarch64-apple-darwin/lib/rustlib/src/rust/library/std/src/sys_common/lazy_box.rs:71:5: 73:6 (#0),
    ),
    body_checked: true,
    raw_ptr_deref: true,
}
[src/fn_visitor.rs:124] body_snippet = "fn deref(&self) -> &T {\n        unsafe { &*self.get_pointer() }\n    }"
[src/fn_visitor.rs:116] fn_call = FnCallInfo {
    def_id: DefId(1:10273 ~ std[e490]::sys::unix::locks::pthread_mutex::{impl#2}::init),
    arg_tys: [],
    call_span: /Users/artemagvanian/.rustup/toolchains/nightly-2023-04-12-aarch64-apple-darwin/lib/rustlib/src/rust/library/std/src/sys_common/lazy_box.rs:55:37: 55:46 (#0),
    body_span: Some(
        /Users/artemagvanian/.rustup/toolchains/nightly-2023-04-12-aarch64-apple-darwin/lib/rustlib/src/rust/library/std/src/sys/unix/locks/pthread_mutex.rs:21:5: 61:6 (#0),
    ),
    body_checked: true,
    raw_ptr_deref: true,
}
[src/fn_visitor.rs:124] body_snippet = "fn init() -> Box<Self> {\n        let mutex = Box::new(AllocatedMutex(UnsafeCell::new(libc::PTHREAD_MUTEX_INITIALIZER)));\n\n        // Issue #33770\n        //\n        // A pthread mutex initialized with PTHREAD_MUTEX_INITIALIZER will have\n        // a type of PTHREAD_MUTEX_DEFAULT, which has undefined behavior if you\n        // try to re-lock it from the same thread when you already hold a lock\n        // (https://pubs.opengroup.org/onlinepubs/9699919799/functions/pthread_mutex_init.html).\n        // This is the case even if PTHREAD_MUTEX_DEFAULT == PTHREAD_MUTEX_NORMAL\n        // (https://github.com/rust-lang/rust/issues/33770#issuecomment-220847521) -- in that\n        // case, `pthread_mutexattr_settype(PTHREAD_MUTEX_DEFAULT)` will of course be the same\n        // as setting it to `PTHREAD_MUTEX_NORMAL`, but not setting any mode will result in\n        // a Mutex where re-locking is UB.\n        //\n        // In practice, glibc takes advantage of this undefined behavior to\n        // implement hardware lock elision, which uses hardware transactional\n        // memory to avoid acquiring the lock. While a transaction is in\n        // progress, the lock appears to be unlocked. This isn't a problem for\n        // other threads since the transactional memory will abort if a conflict\n        // is detected, however no abort is generated when re-locking from the\n        // same thread.\n        //\n        // Since locking the same mutex twice will result in two aliasing &mut\n        // references, we instead create the mutex with type\n        // PTHREAD_MUTEX_NORMAL which is guaranteed to deadlock if we try to\n        // re-lock it from the same thread, thus avoiding undefined behavior.\n        unsafe {\n            let mut attr = MaybeUninit::<libc::pthread_mutexattr_t>::uninit();\n            cvt_nz(libc::pthread_mutexattr_init(attr.as_mut_ptr())).unwrap();\n            let attr = PthreadMutexAttr(&mut attr);\n            cvt_nz(libc::pthread_mutexattr_settype(\n                attr.0.as_mut_ptr(),\n                libc::PTHREAD_MUTEX_NORMAL,\n            ))\n            .unwrap();\n            cvt_nz(libc::pthread_mutex_init(mutex.0.get(), attr.0.as_ptr())).unwrap();\n        }\n\n        mutex\n    }"
[src/fn_visitor.rs:116] fn_call = FnCallInfo {
    def_id: DefId(5:294 ~ alloc[d541]::boxed::{impl#0}::new),
    arg_tys: [
        std::sys::unix::locks::pthread_mutex::AllocatedMutex,
    ],
    call_span: /Users/artemagvanian/.rustup/toolchains/nightly-2023-04-12-aarch64-apple-darwin/lib/rustlib/src/rust/library/std/src/sys/unix/locks/pthread_mutex.rs:22:21: 22:95 (#0),
    body_span: Some(
        /Users/artemagvanian/.rustup/toolchains/nightly-2023-04-12-aarch64-apple-darwin/lib/rustlib/src/rust/library/alloc/src/boxed.rs:218:5: 221:6 (#0),
    ),
    body_checked: true,
    raw_ptr_deref: true,
}
[src/fn_visitor.rs:124] body_snippet = "pub fn new(x: T) -> Self {\n        #[rustc_box]\n        Box::new(x)\n    }"
[src/fn_visitor.rs:116] fn_call = FnCallInfo {
    def_id: DefId(5:108 ~ alloc[d541]::alloc::{extern#0}::__rust_alloc_zeroed),
    arg_tys: [
        usize,
        usize,
    ],
    call_span: /Users/artemagvanian/.rustup/toolchains/nightly-2023-04-12-aarch64-apple-darwin/lib/rustlib/src/rust/library/alloc/src/alloc.rs:164:14: 164:64 (#0),
    body_span: None,
    body_checked: false,
    raw_ptr_deref: false,
}
[src/fn_visitor.rs:116] fn_call = FnCallInfo {
    def_id: DefId(5:105 ~ alloc[d541]::alloc::{extern#0}::__rust_alloc),
    arg_tys: [
        usize,
        usize,
    ],
    call_span: /Users/artemagvanian/.rustup/toolchains/nightly-2023-04-12-aarch64-apple-darwin/lib/rustlib/src/rust/library/alloc/src/alloc.rs:93:14: 93:57 (#0),
    body_span: None,
    body_checked: false,
    raw_ptr_deref: false,
}
[src/fn_visitor.rs:116] fn_call = FnCallInfo {
    def_id: DefId(5:128 ~ alloc[d541]::alloc::{extern#1}::__rust_alloc_error_handler),
    arg_tys: [
        usize,
        usize,
    ],
    call_span: /Users/artemagvanian/.rustup/toolchains/nightly-2023-04-12-aarch64-apple-darwin/lib/rustlib/src/rust/library/alloc/src/alloc.rs:379:13: 379:70 (#0),
    body_span: None,
    body_checked: false,
    raw_ptr_deref: false,
}
[src/fn_visitor.rs:116] fn_call = FnCallInfo {
    def_id: DefId(6:367 ~ libc[4d33]::unix::{extern#1}::pthread_mutexattr_init),
    arg_tys: [
        *mut libc::unix::bsd::apple::pthread_mutexattr_t,
    ],
    call_span: /Users/artemagvanian/.rustup/toolchains/nightly-2023-04-12-aarch64-apple-darwin/lib/rustlib/src/rust/library/std/src/sys/unix/locks/pthread_mutex.rs:50:20: 50:67 (#0),
    body_span: None,
    body_checked: false,
    raw_ptr_deref: false,
}
[src/fn_visitor.rs:116] fn_call = FnCallInfo {
    def_id: DefId(1:2852 ~ std[e490]::io::error::repr_bitpacked::decode_repr),
    arg_tys: [
        std::ptr::NonNull<()>,
        [closure@std::io::error::repr_bitpacked::Repr::data::{closure#0}],
    ],
    call_span: /Users/artemagvanian/.rustup/toolchains/nightly-2023-04-12-aarch64-apple-darwin/lib/rustlib/src/rust/library/std/src/io/error/repr_bitpacked.rs:212:18: 212:46 (#0),
    body_span: Some(
        /Users/artemagvanian/.rustup/toolchains/nightly-2023-04-12-aarch64-apple-darwin/lib/rustlib/src/rust/library/std/src/io/error/repr_bitpacked.rs:246:1: 283:2 (#0),
    ),
    body_checked: true,
    raw_ptr_deref: true,
}
[src/fn_visitor.rs:124] body_snippet = "unsafe fn decode_repr<C, F>(ptr: NonNull<()>, make_custom: F) -> ErrorData<C>\nwhere\n    F: FnOnce(*mut Custom) -> C,\n{\n    let bits = ptr.as_ptr().addr();\n    match bits & TAG_MASK {\n        TAG_OS => {\n            let code = ((bits as i64) >> 32) as RawOsError;\n            ErrorData::Os(code)\n        }\n        TAG_SIMPLE => {\n            let kind_bits = (bits >> 32) as u32;\n            let kind = kind_from_prim(kind_bits).unwrap_or_else(|| {\n                debug_assert!(false, \"Invalid io::error::Repr bits: `Repr({:#018x})`\", bits);\n                // This means the `ptr` passed in was not valid, which violates\n                // the unsafe contract of `decode_repr`.\n                //\n                // Using this rather than unwrap meaningfully improves the code\n                // for callers which only care about one variant (usually\n                // `Custom`)\n                core::hint::unreachable_unchecked();\n            });\n            ErrorData::Simple(kind)\n        }\n        TAG_SIMPLE_MESSAGE => ErrorData::SimpleMessage(&*ptr.cast::<SimpleMessage>().as_ptr()),\n        TAG_CUSTOM => {\n            // It would be correct for us to use `ptr::byte_sub` here (see the\n            // comment above the `wrapping_add` call in `new_custom` for why),\n            // but it isn't clear that it makes a difference, so we don't.\n            let custom = ptr.as_ptr().wrapping_byte_sub(TAG_CUSTOM).cast::<Custom>();\n            ErrorData::Custom(make_custom(custom))\n        }\n        _ => {\n            // Can't happen, and compiler can tell\n            unreachable!();\n        }\n    }\n}"
[src/fn_visitor.rs:116] fn_call = FnCallInfo {
    def_id: DefId(2:1270 ~ core[f767]::intrinsics::{extern#0}::arith_offset),
    arg_tys: [
        *const T,
        isize,
    ],
    call_span: /Users/artemagvanian/.rustup/toolchains/nightly-2023-04-12-aarch64-apple-darwin/lib/rustlib/src/rust/library/core/src/ptr/mut_ptr.rs:558:18: 558:55 (#0),
    body_span: None,
    body_checked: false,
    raw_ptr_deref: false,
}
[src/fn_visitor.rs:116] fn_call = FnCallInfo {
    def_id: DefId(1:2844 ~ std[e490]::io::error::repr_bitpacked::{impl#2}::data::{closure#0}),
    arg_tys: [
        F,
        (*mut std::io::error::Custom,),
    ],
    call_span: /Users/artemagvanian/.rustup/toolchains/nightly-2023-04-12-aarch64-apple-darwin/lib/rustlib/src/rust/library/std/src/io/error/repr_bitpacked.rs:276:31: 276:50 (#0),
    body_span: Some(
        /Users/artemagvanian/.rustup/toolchains/nightly-2023-04-12-aarch64-apple-darwin/lib/rustlib/src/rust/library/std/src/io/error/repr_bitpacked.rs:212:38: 212:45 (#0),
    ),
    body_checked: true,
    raw_ptr_deref: true,
}
[src/fn_visitor.rs:124] body_snippet = "|c| &*c"
[src/fn_visitor.rs:116] fn_call = FnCallInfo {
    def_id: DefId(6:369 ~ libc[4d33]::unix::{extern#1}::pthread_mutexattr_settype),
    arg_tys: [
        *mut libc::unix::bsd::apple::pthread_mutexattr_t,
        i32,
    ],
    call_span: /Users/artemagvanian/.rustup/toolchains/nightly-2023-04-12-aarch64-apple-darwin/lib/rustlib/src/rust/library/std/src/sys/unix/locks/pthread_mutex.rs:52:20: 55:14 (#0),
    body_span: None,
    body_checked: false,
    raw_ptr_deref: false,
}
[src/fn_visitor.rs:116] fn_call = FnCallInfo {
    def_id: DefId(6:362 ~ libc[4d33]::unix::{extern#1}::pthread_mutex_init),
    arg_tys: [
        *mut libc::unix::bsd::apple::pthread_mutex_t,
        *const libc::unix::bsd::apple::pthread_mutexattr_t,
    ],
    call_span: /Users/artemagvanian/.rustup/toolchains/nightly-2023-04-12-aarch64-apple-darwin/lib/rustlib/src/rust/library/std/src/sys/unix/locks/pthread_mutex.rs:57:20: 57:76 (#0),
    body_span: None,
    body_checked: false,
    raw_ptr_deref: false,
}
[src/fn_visitor.rs:116] fn_call = FnCallInfo {
    def_id: DefId(5:345 ~ alloc[d541]::boxed::{impl#7}::leak),
    arg_tys: [
        std::boxed::Box<T, A>,
    ],
    call_span: /Users/artemagvanian/.rustup/toolchains/nightly-2023-04-12-aarch64-apple-darwin/lib/rustlib/src/rust/library/alloc/src/boxed.rs:1118:23: 1118:35 (#0),
    body_span: Some(
        /Users/artemagvanian/.rustup/toolchains/nightly-2023-04-12-aarch64-apple-darwin/lib/rustlib/src/rust/library/alloc/src/boxed.rs:1171:5: 1176:6 (#0),
    ),
    body_checked: true,
    raw_ptr_deref: true,
}
[src/fn_visitor.rs:124] body_snippet = "pub const fn leak<'a>(b: Self) -> &'a mut T\n    where\n        A: 'a,\n    {\n        unsafe { &mut *mem::ManuallyDrop::new(b).0.as_ptr() }\n    }"
[src/fn_visitor.rs:116] fn_call = FnCallInfo {
    def_id: DefId(2:1030 ~ core[f767]::intrinsics::{extern#0}::atomic_cxchg_relaxed_relaxed),
    arg_tys: [
        *mut T,
        T,
        T,
    ],
    call_span: /Users/artemagvanian/.rustup/toolchains/nightly-2023-04-12-aarch64-apple-darwin/lib/rustlib/src/rust/library/core/src/sync/atomic.rs:3231:35: 3231:90 (#0),
    body_span: None,
    body_checked: false,
    raw_ptr_deref: false,
}
[src/fn_visitor.rs:116] fn_call = FnCallInfo {
    def_id: DefId(2:1032 ~ core[f767]::intrinsics::{extern#0}::atomic_cxchg_relaxed_acquire),
    arg_tys: [
        *mut T,
        T,
        T,
    ],
    call_span: /Users/artemagvanian/.rustup/toolchains/nightly-2023-04-12-aarch64-apple-darwin/lib/rustlib/src/rust/library/core/src/sync/atomic.rs:3232:35: 3232:90 (#0),
    body_span: None,
    body_checked: false,
    raw_ptr_deref: false,
}
[src/fn_visitor.rs:116] fn_call = FnCallInfo {
    def_id: DefId(2:1034 ~ core[f767]::intrinsics::{extern#0}::atomic_cxchg_relaxed_seqcst),
    arg_tys: [
        *mut T,
        T,
        T,
    ],
    call_span: /Users/artemagvanian/.rustup/toolchains/nightly-2023-04-12-aarch64-apple-darwin/lib/rustlib/src/rust/library/core/src/sync/atomic.rs:3233:34: 3233:88 (#0),
    body_span: None,
    body_checked: false,
    raw_ptr_deref: false,
}
[src/fn_visitor.rs:116] fn_call = FnCallInfo {
    def_id: DefId(2:1036 ~ core[f767]::intrinsics::{extern#0}::atomic_cxchg_acquire_relaxed),
    arg_tys: [
        *mut T,
        T,
        T,
    ],
    call_span: /Users/artemagvanian/.rustup/toolchains/nightly-2023-04-12-aarch64-apple-darwin/lib/rustlib/src/rust/library/core/src/sync/atomic.rs:3234:35: 3234:90 (#0),
    body_span: None,
    body_checked: false,
    raw_ptr_deref: false,
}
[src/fn_visitor.rs:116] fn_call = FnCallInfo {
    def_id: DefId(2:1038 ~ core[f767]::intrinsics::{extern#0}::atomic_cxchg_acquire_acquire),
    arg_tys: [
        *mut T,
        T,
        T,
    ],
    call_span: /Users/artemagvanian/.rustup/toolchains/nightly-2023-04-12-aarch64-apple-darwin/lib/rustlib/src/rust/library/core/src/sync/atomic.rs:3235:35: 3235:90 (#0),
    body_span: None,
    body_checked: false,
    raw_ptr_deref: false,
}
[src/fn_visitor.rs:116] fn_call = FnCallInfo {
    def_id: DefId(2:1040 ~ core[f767]::intrinsics::{extern#0}::atomic_cxchg_acquire_seqcst),
    arg_tys: [
        *mut T,
        T,
        T,
    ],
    call_span: /Users/artemagvanian/.rustup/toolchains/nightly-2023-04-12-aarch64-apple-darwin/lib/rustlib/src/rust/library/core/src/sync/atomic.rs:3236:34: 3236:88 (#0),
    body_span: None,
    body_checked: false,
    raw_ptr_deref: false,
}
[src/fn_visitor.rs:116] fn_call = FnCallInfo {
    def_id: DefId(2:1042 ~ core[f767]::intrinsics::{extern#0}::atomic_cxchg_release_relaxed),
    arg_tys: [
        *mut T,
        T,
        T,
    ],
    call_span: /Users/artemagvanian/.rustup/toolchains/nightly-2023-04-12-aarch64-apple-darwin/lib/rustlib/src/rust/library/core/src/sync/atomic.rs:3237:35: 3237:90 (#0),
    body_span: None,
    body_checked: false,
    raw_ptr_deref: false,
}
[src/fn_visitor.rs:116] fn_call = FnCallInfo {
    def_id: DefId(2:1044 ~ core[f767]::intrinsics::{extern#0}::atomic_cxchg_release_acquire),
    arg_tys: [
        *mut T,
        T,
        T,
    ],
    call_span: /Users/artemagvanian/.rustup/toolchains/nightly-2023-04-12-aarch64-apple-darwin/lib/rustlib/src/rust/library/core/src/sync/atomic.rs:3238:35: 3238:90 (#0),
    body_span: None,
    body_checked: false,
    raw_ptr_deref: false,
}
[src/fn_visitor.rs:116] fn_call = FnCallInfo {
    def_id: DefId(2:1046 ~ core[f767]::intrinsics::{extern#0}::atomic_cxchg_release_seqcst),
    arg_tys: [
        *mut T,
        T,
        T,
    ],
    call_span: /Users/artemagvanian/.rustup/toolchains/nightly-2023-04-12-aarch64-apple-darwin/lib/rustlib/src/rust/library/core/src/sync/atomic.rs:3239:34: 3239:88 (#0),
    body_span: None,
    body_checked: false,
    raw_ptr_deref: false,
}
[src/fn_visitor.rs:116] fn_call = FnCallInfo {
    def_id: DefId(2:1048 ~ core[f767]::intrinsics::{extern#0}::atomic_cxchg_acqrel_relaxed),
    arg_tys: [
        *mut T,
        T,
        T,
    ],
    call_span: /Users/artemagvanian/.rustup/toolchains/nightly-2023-04-12-aarch64-apple-darwin/lib/rustlib/src/rust/library/core/src/sync/atomic.rs:3240:34: 3240:88 (#0),
    body_span: None,
    body_checked: false,
    raw_ptr_deref: false,
}
[src/fn_visitor.rs:116] fn_call = FnCallInfo {
    def_id: DefId(2:1050 ~ core[f767]::intrinsics::{extern#0}::atomic_cxchg_acqrel_acquire),
    arg_tys: [
        *mut T,
        T,
        T,
    ],
    call_span: /Users/artemagvanian/.rustup/toolchains/nightly-2023-04-12-aarch64-apple-darwin/lib/rustlib/src/rust/library/core/src/sync/atomic.rs:3241:34: 3241:88 (#0),
    body_span: None,
    body_checked: false,
    raw_ptr_deref: false,
}
[src/fn_visitor.rs:116] fn_call = FnCallInfo {
    def_id: DefId(2:1052 ~ core[f767]::intrinsics::{extern#0}::atomic_cxchg_acqrel_seqcst),
    arg_tys: [
        *mut T,
        T,
        T,
    ],
    call_span: /Users/artemagvanian/.rustup/toolchains/nightly-2023-04-12-aarch64-apple-darwin/lib/rustlib/src/rust/library/core/src/sync/atomic.rs:3242:33: 3242:86 (#0),
    body_span: None,
    body_checked: false,
    raw_ptr_deref: false,
}
[src/fn_visitor.rs:116] fn_call = FnCallInfo {
    def_id: DefId(2:1054 ~ core[f767]::intrinsics::{extern#0}::atomic_cxchg_seqcst_relaxed),
    arg_tys: [
        *mut T,
        T,
        T,
    ],
    call_span: /Users/artemagvanian/.rustup/toolchains/nightly-2023-04-12-aarch64-apple-darwin/lib/rustlib/src/rust/library/core/src/sync/atomic.rs:3243:34: 3243:88 (#0),
    body_span: None,
    body_checked: false,
    raw_ptr_deref: false,
}
[src/fn_visitor.rs:116] fn_call = FnCallInfo {
    def_id: DefId(2:1056 ~ core[f767]::intrinsics::{extern#0}::atomic_cxchg_seqcst_acquire),
    arg_tys: [
        *mut T,
        T,
        T,
    ],
    call_span: /Users/artemagvanian/.rustup/toolchains/nightly-2023-04-12-aarch64-apple-darwin/lib/rustlib/src/rust/library/core/src/sync/atomic.rs:3244:34: 3244:88 (#0),
    body_span: None,
    body_checked: false,
    raw_ptr_deref: false,
}
[src/fn_visitor.rs:116] fn_call = FnCallInfo {
    def_id: DefId(2:1058 ~ core[f767]::intrinsics::{extern#0}::atomic_cxchg_seqcst_seqcst),
    arg_tys: [
        *mut T,
        T,
        T,
    ],
    call_span: /Users/artemagvanian/.rustup/toolchains/nightly-2023-04-12-aarch64-apple-darwin/lib/rustlib/src/rust/library/core/src/sync/atomic.rs:3245:33: 3245:86 (#0),
    body_span: None,
    body_checked: false,
    raw_ptr_deref: false,
}
[src/fn_visitor.rs:116] fn_call = FnCallInfo {
    def_id: DefId(6:364 ~ libc[4d33]::unix::{extern#1}::pthread_mutex_lock),
    arg_tys: [
        *mut libc::unix::bsd::apple::pthread_mutex_t,
    ],
    call_span: /Users/artemagvanian/.rustup/toolchains/nightly-2023-04-12-aarch64-apple-darwin/lib/rustlib/src/rust/library/std/src/sys/unix/locks/pthread_mutex.rs:106:17: 106:52 (#0),
    body_span: None,
    body_checked: false,
    raw_ptr_deref: false,
}
[src/fn_visitor.rs:116] fn_call = FnCallInfo {
    def_id: DefId(1:6148 ~ std[e490]::sync::mutex::{impl#11}::deref_mut),
    arg_tys: [
        &mut std::sync::MutexGuard<'_, std::vec::Vec<u8>>,
    ],
    call_span: /Users/artemagvanian/.rustup/toolchains/nightly-2023-04-12-aarch64-apple-darwin/lib/rustlib/src/rust/library/std/src/io/stdio.rs:1030:25: 1030:84 (#0),
    body_span: Some(
        /Users/artemagvanian/.rustup/toolchains/nightly-2023-04-12-aarch64-apple-darwin/lib/rustlib/src/rust/library/std/src/sync/mutex.rs:524:5: 526:6 (#0),
    ),
    body_checked: true,
    raw_ptr_deref: true,
}
[src/fn_visitor.rs:124] body_snippet = "fn deref_mut(&mut self) -> &mut T {\n        unsafe { &mut *self.lock.data.get() }\n    }"
[src/fn_visitor.rs:116] fn_call = FnCallInfo {
    def_id: DefId(2:1268 ~ core[f767]::intrinsics::{extern#0}::offset),
    arg_tys: [
        *const T,
        isize,
    ],
    call_span: /Users/artemagvanian/.rustup/toolchains/nightly-2023-04-12-aarch64-apple-darwin/lib/rustlib/src/rust/library/core/src/ptr/const_ptr.rs:465:18: 465:49 (#0),
    body_span: None,
    body_checked: false,
    raw_ptr_deref: false,
}
[src/fn_visitor.rs:116] fn_call = FnCallInfo {
    def_id: DefId(2:35944 ~ core[f767]::slice::iter::{impl#181}::next),
    arg_tys: [
        &mut I,
    ],
    call_span: /Users/artemagvanian/.rustup/toolchains/nightly-2023-04-12-aarch64-apple-darwin/lib/rustlib/src/rust/library/core/src/iter/adapters/enumerate.rs:47:27: 47:33 (#0),
    body_span: Some(
        /Users/artemagvanian/.rustup/toolchains/nightly-2023-04-12-aarch64-apple-darwin/lib/rustlib/src/rust/library/core/src/slice/iter/macros.rs:124:13: 142:14 (#132),
    ),
    body_checked: true,
    raw_ptr_deref: true,
}
[src/fn_visitor.rs:124] body_snippet = "fn next(&mut self) -> Option<$elem> {\n                // could be implemented with slices, but this avoids bounds checks\n\n                // SAFETY: `assume` calls are safe since a slice's start pointer\n                // must be non-null, and slices over non-ZSTs must also have a\n                // non-null end pointer. The call to `next_unchecked!` is safe\n                // since we check if the iterator is empty first.\n                unsafe {\n                    assume(!self.ptr.as_ptr().is_null());\n                    if !<T>::IS_ZST {\n                        assume(!self.end.is_null());\n                    }\n                    if is_empty!(self) {\n                        None\n                    } else {\n                        Some(next_unchecked!(self))\n                    }\n                }\n            }"
[src/fn_visitor.rs:116] fn_call = FnCallInfo {
    def_id: DefId(2:10892 ~ core[f767]::slice::{impl#0}::get_unchecked),
    arg_tys: [
        &[&str],
        usize,
    ],
    call_span: /Users/artemagvanian/.rustup/toolchains/nightly-2023-04-12-aarch64-apple-darwin/lib/rustlib/src/rust/library/core/src/fmt/mod.rs:1250:50: 1250:66 (#0),
    body_span: Some(
        /Users/artemagvanian/.rustup/toolchains/nightly-2023-04-12-aarch64-apple-darwin/lib/rustlib/src/rust/library/core/src/slice/mod.rs:398:5: 406:6 (#0),
    ),
    body_checked: true,
    raw_ptr_deref: true,
}
[src/fn_visitor.rs:124] body_snippet = "pub const unsafe fn get_unchecked<I>(&self, index: I) -> &I::Output\n    where\n        I: ~const SliceIndex<Self>,\n    {\n        // SAFETY: the caller must uphold most of the safety requirements for `get_unchecked`;\n        // the slice is dereferenceable because `self` is a safe reference.\n        // The returned pointer is safe because impls of `SliceIndex` have to guarantee that it is.\n        unsafe { &*index.get_unchecked(self) }\n    }"
[src/fn_visitor.rs:116] fn_call = FnCallInfo {
    def_id: DefId(2:9010 ~ core[f767]::fmt::Write::write_str),
    arg_tys: [
        &mut dyn std::fmt::Write,
        &str,
    ],
    call_span: /Users/artemagvanian/.rustup/toolchains/nightly-2023-04-12-aarch64-apple-darwin/lib/rustlib/src/rust/library/core/src/fmt/mod.rs:1252:35: 1252:52 (#0),
    body_span: None,
    body_checked: false,
    raw_ptr_deref: false,
}
[src/fn_visitor.rs:116] fn_call = FnCallInfo {
    def_id: DefId(2:35944 ~ core[f767]::slice::iter::{impl#181}::next),
    arg_tys: [
        &mut I,
    ],
    call_span: /Users/artemagvanian/.rustup/toolchains/nightly-2023-04-12-aarch64-apple-darwin/lib/rustlib/src/rust/library/core/src/iter/adapters/enumerate.rs:47:27: 47:33 (#0),
    body_span: Some(
        /Users/artemagvanian/.rustup/toolchains/nightly-2023-04-12-aarch64-apple-darwin/lib/rustlib/src/rust/library/core/src/slice/iter/macros.rs:124:13: 142:14 (#132),
    ),
    body_checked: true,
    raw_ptr_deref: true,
}
[src/fn_visitor.rs:124] body_snippet = "fn next(&mut self) -> Option<$elem> {\n                // could be implemented with slices, but this avoids bounds checks\n\n                // SAFETY: `assume` calls are safe since a slice's start pointer\n                // must be non-null, and slices over non-ZSTs must also have a\n                // non-null end pointer. The call to `next_unchecked!` is safe\n                // since we check if the iterator is empty first.\n                unsafe {\n                    assume(!self.ptr.as_ptr().is_null());\n                    if !<T>::IS_ZST {\n                        assume(!self.end.is_null());\n                    }\n                    if is_empty!(self) {\n                        None\n                    } else {\n                        Some(next_unchecked!(self))\n                    }\n                }\n            }"
[src/fn_visitor.rs:116] fn_call = FnCallInfo {
    def_id: DefId(2:9045 ~ core[f767]::fmt::{impl#3}::as_usize),
    arg_tys: [
        &core::fmt::ArgumentV1<'_>,
    ],
    call_span: /Users/artemagvanian/.rustup/toolchains/nightly-2023-04-12-aarch64-apple-darwin/lib/rustlib/src/rust/library/core/src/fmt/mod.rs:1313:44: 1313:54 (#0),
    body_span: Some(
        /Users/artemagvanian/.rustup/toolchains/nightly-2023-04-12-aarch64-apple-darwin/lib/rustlib/src/rust/library/core/src/fmt/mod.rs:368:5: 380:6 (#0),
    ),
    body_checked: true,
    raw_ptr_deref: true,
}
[src/fn_visitor.rs:124] body_snippet = "fn as_usize(&self) -> Option<usize> {\n        // We are type punning a bit here: USIZE_MARKER only takes an &usize but\n        // formatter takes an &Opaque. Rust understandably doesn't think we should compare\n        // the function pointers if they don't have the same signature, so we cast to\n        // usizes to tell it that we just want to compare addresses.\n        if self.formatter as usize == USIZE_MARKER as usize {\n            // SAFETY: The `formatter` field is only set to USIZE_MARKER if\n            // the value is a usize, so this is safe\n            Some(unsafe { *(self.value as *const _ as *const usize) })\n        } else {\n            None\n        }\n    }"
[src/fn_visitor.rs:116] fn_call = FnCallInfo {
    def_id: DefId(2:9767 ~ core[f767]::slice::index::{impl#2}::get),
    arg_tys: [
        I,
        &[T],
    ],
    call_span: /Users/artemagvanian/.rustup/toolchains/nightly-2023-04-12-aarch64-apple-darwin/lib/rustlib/src/rust/library/core/src/slice/mod.rs:343:15: 343:24 (#0),
    body_span: Some(
        /Users/artemagvanian/.rustup/toolchains/nightly-2023-04-12-aarch64-apple-darwin/lib/rustlib/src/rust/library/core/src/slice/index.rs:218:5: 221:6 (#0),
    ),
    body_checked: true,
    raw_ptr_deref: true,
}
[src/fn_visitor.rs:124] body_snippet = "fn get(self, slice: &[T]) -> Option<&T> {\n        // SAFETY: `self` is checked to be in bounds.\n        if self < slice.len() { unsafe { Some(&*self.get_unchecked(slice)) } } else { None }\n    }"
Body purity check result for function println_side_effect: false